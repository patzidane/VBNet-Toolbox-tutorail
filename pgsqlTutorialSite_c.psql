CREATE TABLE contacts(
    id INT GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(15),
    PRIMARY KEY (id)
);

INSERT INTO contacts(first_name, last_name, email, phone)
VALUES
    ('John','Doe','john.doe@example.com',NULL),
    ('Lily','Bush','lily.bush@example.com','(408-234-2764)');

select first_name 
    from contacts 
    where phone is null;
    --where phone is null;

select first_name 
    from contacts 
    where phone = null;
    --Even though there is a NULL in the phone column, 
    --the expression NULL = NULL returns false. This is because 
    --NULL is not equal to any value even itself.

SELECT
    first_name || ' ' || last_name AS full_name
FROM
    customer ORDER BY full_name;

--Join
CREATE TABLE basket_a (
    id INT PRIMARY KEY,
    fruit VARCHAR (100) NOT NULL
);

CREATE TABLE basket_b (
    id INT PRIMARY KEY,
    fruit VARCHAR (100) NOT NULL
);
 
INSERT INTO basket_a (id, fruit)
VALUES
    (1, 'Apple'),
    (2, 'Orange'),
    (3, 'Banana'),
    (4, 'Cucumber');
 
INSERT INTO basket_b (id, fruit)
VALUES
    (1, 'Orange'),
    (2, 'Apple'),
    (3, 'Watermelon'),
    (4, 'Pear');
	
SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
INNER JOIN basket_b b ON a.fruit = b.fruit;
	
SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
LEFT JOIN basket_b b ON a.fruit = b.fruit;

SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
LEFT JOIN basket_b b ON a.fruit = b.fruit
WHERE b.id IS NULL; -- left outer join
	
SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
RIGHT JOIN basket_b b ON a.fruit = b.fruit;

SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
RIGHT JOIN basket_b b ON a.fruit = b.fruit
WHERE a.id IS NULL; --right outer join

-- full join and full outer join 	
SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
FULL OUTER JOIN basket_b b ON a.fruit = b.fruit; --full outer join(full join)

SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
FULL outer JOIN basket_b b ON a.fruit = b.fruit
where a.id is NULL or b.id is null; --full outer join

SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
FULL JOIN basket_b b ON a.fruit = b.fruit; --full join
 --WHERE a.id IS NULL OR b.id IS NULL;

 SELECT
    a.id id_a,
    a.fruit fruit_a,
    b.id id_b,
    b.fruit fruit_b
FROM
    basket_a a
FULL JOIN basket_b b ON a.fruit = b.fruit
 WHERE a.id IS NULL OR b.id IS NULL; --full join (full outer join)

--inner join
 select
    customer.customer_id, first_name, last_name, email, amount, payment_date
    from customer
    inner join payment on customer.customer_id = payment.customer_id;

 select
    customer.customer_id, first_name, last_name, email, amount, payment_date
    from customer
    inner join payment on customer.customer_id = payment.customer_id
    --where customer.customer_id is null 
    --or payment.customer_id is null;
    where customer.customer_id = 2;
    --order by customer.customer_id;

select
    customer.customer_id, customer.first_name, customer.last_name, customer.email, 
    amount, payment_date,
    staff.first_name || ' ' || staff.last_name as staff_name
    from customer
    inner join payment on customer.customer_id = payment.customer_id
    inner join staff on payment.staff_id = staff.staff_id;

--Full outer join	
CREATE TABLE
IF NOT EXISTS departments (
 department_id serial PRIMARY KEY,
 department_name VARCHAR (255) NOT NULL
);
 
CREATE TABLE
IF NOT EXISTS employees (
 employee_id serial PRIMARY KEY,
 employee_name VARCHAR (255),
 department_id INTEGER
);
	
INSERT INTO departments (department_name)
VALUES
 ('Sales'),
 ('Marketing'),
 ('HR'),
 ('IT'),
 ('Production');
 
INSERT INTO employees (
 employee_name,
 department_id
)
VALUES
 ('Bette Nicholson', 1),
 ('Christian Gable', 1),
 ('Joe Swank', 2),
 ('Fred Costner', 3),
 ('Sandra Kilmer', 4),
 ('Julia Mcqueen', NULL);

 select employee_name, department_name
    from employees e
    full outer join departments d 
    --on e.employee_id = d.department_id; wrong
    on d.department_id = e.department_id;

select employee_name, department_name
    from employees e 
    full outer join departments d
    on d.department_id = e.department_id
    where e.employee_name is null;
    --where employee_name is null;

select employee_name, department_name
    from employees e 
    full outer join departments d
    on d.department_id = e.department_id
    where d.department_name is null;
    --where department_name is null;
	
    --left join
SELECT
    film.film_id, film.title, inventory_id
    FROM
    film
    LEFT JOIN inventory ON film.film_id = inventory.film_id;

select 
    film.film_id, film.title, inventory_id
    from film
    left join inventory on film.film_id = inventory.film_id
    where inventory.film_id is null;

--self join
CREATE TABLE employee (
 employee_id INT PRIMARY KEY,
 first_name VARCHAR (255) NOT NULL,
 last_name VARCHAR (255) NOT NULL,
 manager_id INT,
 FOREIGN KEY (manager_id) 
 REFERENCES employee (employee_id) 
 ON DELETE CASCADE
);

INSERT INTO employee (
 employee_id,
 first_name,
 last_name,
 manager_id
)
VALUES
 (1, 'Windy', 'Hays', NULL),
 (2, 'Ava', 'Christensen', 1),
 (3, 'Hassan', 'Conner', 1),
 (4, 'Anna', 'Reeves', 2),
 (5, 'Sau', 'Norman', 2),
 (6, 'Kelsie', 'Hays', 3),
 (7, 'Tory', 'Goff', 3),
 (8, 'Salley', 'Lester', 3);

 select e.first_name || ' ' || e.last_name employee,
    m.first_name|| ' ' || m.last_name manager
    from employee e
    inner join employee m
   -- on e.employee_id = m.manager_id;
    on m.employee_id = e.manager_id;

 select e.first_name || ' ' || e.last_name employee,
    m.first_name|| ' ' || m.last_name manager
    from employee e
    inner join employee m
   -- on e.employee_id = m.manager_id;
    on m.employee_id = e.manager_id
    --order by manager;
    order by e.manager_id;

select f1.title, f2.title, f1.length
    from film f1
    INNER JOIN film f2 ON f1.film_id <> f2.film_id --nicht gleicher film
    AND f1.length = f2.length;
    --on f1.film_id = f2.film_id --Gleicher Film
    --where f1.length = f2.length; 

    --natural JOIN
SELECT *
FROM T1
NATURAL [INNER, LEFT, RIGHT] JOIN T2;

CREATE TABLE categories (
 category_id serial PRIMARY KEY,
 category_name VARCHAR (255) NOT NULL
);
 
CREATE TABLE products (
 product_id serial PRIMARY KEY,
 product_name VARCHAR (255) NOT NULL,
 category_id INT NOT NULL,
 FOREIGN KEY (category_id) REFERENCES categories (category_id)
);

INSERT INTO categories (category_name)
VALUES
 ('Smart Phone'),
 ('Laptop'),
 ('Tablet');
 
INSERT INTO products (product_name, category_id)
VALUES
 ('iPhone', 1),
 ('Samsung Galaxy', 1),
 ('HP Elite', 2),
 ('Lenovo Thinkpad', 2),
 ('iPad', 3),
 ('Kindle Fire', 3);

 select * from products
 NATURAL join categories;

 select * from products
 inner join categories using(category_id);

 select * from products
 inner join categories on products.category_id = categories.category_id;

 --However, you should avoid using the NATURAL JOIN 
 --whenever possible because sometimes it may cause an unexpected result.

--For example, letâ€™s take a look at the city and country tables. 
--Both tables have the same country_id column

--cross join
create table t3 (label char(1) primary key);

create table t4 (score int primary key);

INSERT INTO t3 (label)
VALUES
 ('A'),
 ('B');
 
INSERT INTO t4 (score)
VALUES
 (1),
 (2),
 (3);

select * from t3 cross join t4;

 --group by
select customer_id 
    from payment group by customer_id;
    --the GROUP BY acts like the DISTINCT clause 
    --that removes the duplicate rows from the result set.

select customer_id, sum(amount)
from payment
group by customer_id;

select customer_id, sum(amount)
from payment
group by customer_id
order by sum(amount) desc;

select staff_id, count(payment_id)
    from payment
    group by staff_id;

--having
select customer_id, sum(amount)
from payment
group by customer_id
having sum (amount) > 200;

select store_id, count(customer_id)
    from customer
    group by store_id;

select store_id, count(customer_id)
    from customer
    group by store_id
    having count(customer_id) > 300;

--union
SELECT * FROM sales2007q1
UNION
SELECT * FROM sales2007q2; 
--union removes all duplicate rows unless the UNION ALL is used.

SELECT * FROM sales2007q1
UNION ALL
SELECT * FROM sales2007q2; --union ALL

SELECT * FROM sales2007q1
UNION ALL
SELECT * FROM sales2007q2
ORDER BY 
 name ASC,
 amount DESC;

 --intersect
CREATE TABLE employees_v2 (
 employee_id serial PRIMARY KEY,
 employee_name VARCHAR (255) NOT NULL
);
 
CREATE TABLE keys (
 employee_id INT PRIMARY KEY,
 effective_date DATE NOT NULL,
 FOREIGN KEY (employee_id) REFERENCES employees_v2 (employee_id)
);
 
CREATE TABLE hipos (
 employee_id INT PRIMARY KEY,
 effective_date DATE NOT NULL,
 FOREIGN KEY (employee_id) REFERENCES employees_v2 (employee_id)
);

INSERT INTO employees_v2 (employee_name)
VALUES
 ('Joyce Edwards'),
 ('Diane Collins'),
 ('Alice Stewart'),
 ('Julie Sanchez'),
 ('Heather Morris'),
 ('Teresa Rogers'),
 ('Doris Reed'),
 ('Gloria Cook'),
 ('Evelyn Morgan'),
 ('Jean Bell');
 
INSERT INTO keys
VALUES
 (1, '2000-02-01'),
 (2, '2001-06-01'),
 (5, '2002-01-01'),
 (7, '2005-06-01');
 
INSERT INTO hipos
VALUES
 (9, '2000-01-01'),
 (2, '2002-06-01'),
 (5, '2006-06-01'),
 (10, '2005-06-01');

 select employee_id from keys;

 select employee_id from hipos;

 select employee_id from keys
 intersect
 select employee_id from hipos;

  select employee_id from keys
 intersect
 select employee_id from hipos
 order by employee_id desc; 

 --except
 select film_id, title from film
 order by title;

 select distinct inventory.film_id, title
 from inventory
 inner join film on film.film_id = inventory.film_id
 order by title;

select film_id, title from film
 EXCEPT
 select distinct inventory.film_id, title
 from inventory
 inner join film on film.film_id = inventory.film_id
 order by title;

 --grouping sets
 CREATE TABLE sales (
    brand VARCHAR NOT NULL,
    segment VARCHAR NOT NULL,
    quantity INT NOT NULL,
    PRIMARY KEY (brand, segment)
);
 
INSERT INTO sales (brand, segment, quantity)
VALUES
    ('ABC', 'Premium', 100),
    ('ABC', 'Basic', 200),
    ('XYZ', 'Premium', 100),
    ('XYZ', 'Basic', 300);

select brand, segment, sum(quantity)
from sales
group by brand, segment;

select brand, sum(quantity)
from sales
group by brand;

select segment, sum(quantity)
from sales
group by segment;

SELECT sum(quantity)
from sales;

select brand, segment, sum(quantity)
from sales
group by brand, segment
union ALL
select brand, null, sum(quantity)
from sales
group by brand
union ALL
select null, segment, sum(quantity)
from sales
group by segment
union ALL
select null, null, sum(quantity)
from sales;

select brand, segment, sum(quantity)
from sales
group by 
    grouping sets(
        (brand, segment),
        (brand),
        (segment),
        ()
    ); --will not scan it separately for each grouping set

SELECT
 GROUPING(brand) grouping_brand,
 GROUPING(segment) grouping_segement,
 brand,
 segment,
 SUM (quantity)
FROM
 sales
GROUP BY
 GROUPING SETS (
 (brand, segment),
 (brand),
 (segment),
 ()
 )
ORDER BY
 brand,
 segment;

 --cube
 CUBE(c1,c2,c3) 
 
GROUPING SETS (
    (c1,c2,c3), 
    (c1,c2),
    (c1,c3),
    (c2,c3),
    (c1),
    (c2),
    (c3), 
    ()
 ) -- different cube and grouping sets

SELECT
    brand,
    segment,
    SUM (quantity)
FROM
    sales
    GROUP BY
        CUBE (brand, segment)
    ORDER BY
        brand,
        segment;

SELECT
    brand,
    segment,
    SUM (quantity)
FROM
    sales
GROUP BY
    brand,
    CUBE (segment)
ORDER BY
    brand,
    segment; --in brand there is null will remove it